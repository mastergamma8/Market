import os
import json
import random
import itertools
import datetime
import asyncio
import hashlib
import hmac
import urllib.parse
from typing import Tuple

from aiogram import Bot, Dispatcher
from aiogram.client.bot import DefaultBotProperties
from aiogram.enums import ParseMode
from aiogram.filters import Command
from aiogram.types import Message

# –ò–º–ø–æ—Ä—Ç –¥–ª—è –≤–µ–±-–ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è
import uvicorn
from fastapi import FastAPI, Request, Form
from fastapi.responses import HTMLResponse, RedirectResponse
from fastapi.staticfiles import StaticFiles
from fastapi.templating import Jinja2Templates

# –ó–∞–º–µ–Ω–∏—Ç–µ –Ω–∞ —Ç–æ–∫–µ–Ω –≤–∞—à–µ–≥–æ –±–æ—Ç–∞
BOT_TOKEN = "7846917008:AAGaj9ZsWnb_2GmZC0q7YqTQEV39l0eBHxs"
DATA_FILE = "data.json"

# –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –±–æ—Ç–∞ (aiogram)
bot = Bot(
    token=BOT_TOKEN,
    default_bot_properties=DefaultBotProperties(parse_mode=ParseMode.HTML)
)
dp = Dispatcher()

# –§—É–Ω–∫—Ü–∏–∏ —Ä–∞–±–æ—Ç—ã —Å –¥–∞–Ω–Ω—ã–º–∏
def load_data() -> dict:
    """–ó–∞–≥—Ä—É–∂–∞–µ—Ç –¥–∞–Ω–Ω—ã–µ –∏–∑ JSON-—Ñ–∞–π–ª–∞."""
    if not os.path.exists(DATA_FILE):
        return {}
    with open(DATA_FILE, "r", encoding="utf-8") as file:
        try:
            return json.load(file)
        except json.JSONDecodeError:
            return {}

def save_data(data: dict) -> None:
    """–°–æ—Ö—Ä–∞–Ω—è–µ—Ç –¥–∞–Ω–Ω—ã–µ –≤ JSON-—Ñ–∞–π–ª."""
    with open(DATA_FILE, "w", encoding="utf-8") as file:
        json.dump(data, file, ensure_ascii=False, indent=2)

def ensure_user(data: dict, user_id: str, username: str = "Unknown", photo_url: str = None) -> dict:
    """
    –ü—Ä–æ–≤–µ—Ä—è–µ—Ç, —Å—É—â–µ—Å—Ç–≤—É–µ—Ç –ª–∏ –∑–∞–ø–∏—Å—å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –ø–æ user_id.
    –ï—Å–ª–∏ –Ω–µ—Ç ‚Äì —Å–æ–∑–¥–∞—ë—Ç –µ—ë —Å –Ω–∞—á–∞–ª—å–Ω—ã–º–∏ –∑–Ω–∞—á–µ–Ω–∏—è–º–∏.
    """
    today = datetime.date.today().isoformat()
    if "users" not in data:
        data["users"] = {}
    if user_id not in data["users"]:
        data["users"][user_id] = {
            "last_activation_date": today,
            "activation_count": 0,
            "tokens": [],
            "balance": 1000,
            "username": username,
            "photo_url": photo_url,
            "login_code": None,
            "code_expiry": None
        }
    return data["users"][user_id]

def beauty_score(num_str: str) -> int:
    """–í—ã—á–∏—Å–ª—è–µ—Ç ¬´–∫—Ä–∞—Å–æ—Ç—É¬ª –Ω–æ–º–µ—Ä–∞."""
    zeros = num_str.count("0")
    max_repeats = max(len(list(group)) for _, group in itertools.groupby(num_str))
    bonus = 6 - len(num_str)
    return zeros + max_repeats + bonus

def generate_number() -> Tuple[str, int]:
    """–ì–µ–Ω–µ—Ä–∏—Ä—É–µ—Ç –Ω–æ–º–µ—Ä —Å —É—á–µ—Ç–æ–º —Ä–µ–¥–∫–æ—Å—Ç–∏."""
    while True:
        length = random.choices([3, 4, 5, 6], weights=[1, 2, 3, 4])[0]
        candidate = "".join(random.choices("0123456789", k=length))
        score = beauty_score(candidate)
        if random.random() < 1 / (score + 1):
            return candidate, score

def generate_login_code() -> str:
    """–ì–µ–Ω–µ—Ä–∏—Ä—É–µ—Ç 6-–∑–Ω–∞—á–Ω—ã–π –∫–æ–¥ –¥–ª—è –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏—è –≤—Ö–æ–¥–∞."""
    return str(random.randint(100000, 999999))

# --------------------- Telegram Bot Handlers ---------------------
@dp.message(Command("start"))
async def start_cmd(message: Message) -> None:
    data = load_data()
    user = ensure_user(data, str(message.from_user.id),
                        message.from_user.username or message.from_user.first_name)
    save_data(data)
    text = (
        "üéâ –î–æ–±—Ä–æ –ø–æ–∂–∞–ª–æ–≤–∞—Ç—å –≤ Market –∫–æ–ª–ª–µ–∫—Ü–∏–æ–Ω–Ω—ã—Ö –Ω–æ–º–µ—Ä–æ–≤! üéâ\n\n"
        "–ß—Ç–æ–±—ã –≤–æ–π—Ç–∏ –≤ –∞–∫–∫–∞—É–Ω—Ç, –∏—Å–ø–æ–ª—å–∑—É–π—Ç–µ –∫–æ–º–∞–Ω–¥—É /login <–í–∞—à Telegram ID>.\n"
        "–ü–æ—Å–ª–µ —ç—Ç–æ–≥–æ –±–æ—Ç –æ—Ç–ø—Ä–∞–≤–∏—Ç –≤–∞–º –∫–æ–¥ –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏—è, –∫–æ—Ç–æ—Ä—ã–π –Ω—É–∂–Ω–æ –≤–≤–µ—Å—Ç–∏ –Ω–∞ —Å–∞–π—Ç–µ.\n"
        "–¢–∞–∫–∂–µ –¥–æ—Å—Ç—É–ø–Ω—ã —Å–ª–µ–¥—É—é—â–∏–µ –∫–æ–º–∞–Ω–¥—ã:\n"
        "‚Ä¢ /mint, /collection, /balance, /sell, /market, /buy, /participants, /exchange."
    )
    await message.answer(text)

@dp.message(Command("login"))
async def login_cmd(message: Message) -> None:
    """
    –ö–æ–º–∞–Ω–¥–∞ /login <ID> –∏–Ω–∏—Ü–∏–∏—Ä—É–µ—Ç –æ—Ç–ø—Ä–∞–≤–∫—É –∫–æ–¥–∞ –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏—è –Ω–∞ —É–∫–∞–∑–∞–Ω–Ω—ã–π Telegram ID.
    –ï—Å–ª–∏ ID —Å–æ–≤–ø–∞–¥–∞–µ—Ç —Å –≤–∞—à–∏–º (message.from_user.id), –∫–æ–¥ –±—É–¥–µ—Ç –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω –Ω–∞ –≤–∞—à –∞–∫–∫–∞—É–Ω—Ç.
    """
    parts = message.text.split()
    if len(parts) != 2:
        await message.answer("‚ùó –§–æ—Ä–º–∞—Ç: /login <–í–∞—à Telegram ID>")
        return
    user_id = parts[1]
    # –î–ª—è –±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç–∏ –ø—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ ID –∏–∑ –∫–æ–º–∞–Ω–¥—ã —Å–æ–≤–ø–∞–¥–∞–µ—Ç —Å ID –æ—Ç–ø—Ä–∞–≤–∏—Ç–µ–ª—è
    if user_id != str(message.from_user.id):
        await message.answer("‚ùó –í—ã –º–æ–∂–µ—Ç–µ –≤–æ–π—Ç–∏ —Ç–æ–ª—å–∫–æ –≤ —Å–≤–æ–π –∞–∫–∫–∞—É–Ω—Ç.")
        return
    data = load_data()
    user = ensure_user(data, user_id,
                       message.from_user.username or message.from_user.first_name)
    # –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º –∫–æ–¥ –∏ —É—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –≤—Ä–µ–º—è –∏—Å—Ç–µ—á–µ–Ω–∏—è (–Ω–∞–ø—Ä–∏–º–µ—Ä, 5 –º–∏–Ω—É—Ç)
    code = generate_login_code()
    expiry = (datetime.datetime.now() + datetime.timedelta(minutes=5)).timestamp()
    user["login_code"] = code
    user["code_expiry"] = expiry
    save_data(data)
    # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –∫–æ–¥ –Ω–∞ Telegram
    try:
        await bot.send_message(int(user_id), f"–í–∞—à –∫–æ–¥ –¥–ª—è –≤—Ö–æ–¥–∞: {code}")
        await message.answer("–ö–æ–¥ –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏—è –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω –Ω–∞ –≤–∞—à Telegram. –í–≤–µ–¥–∏—Ç–µ –µ–≥–æ –Ω–∞ —Å–∞–π—Ç–µ –¥–ª—è –≤—Ö–æ–¥–∞.")
    except Exception as e:
        await message.answer("–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ—Ç–ø—Ä–∞–≤–∫–µ –∫–æ–¥–∞. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ.")
        print("–û—à–∏–±–∫–∞ –æ—Ç–ø—Ä–∞–≤–∫–∏ –∫–æ–¥–∞:", e)

# --------------------- –í–µ–±-–ø—Ä–∏–ª–æ–∂–µ–Ω–∏–µ (FastAPI) ---------------------
app = FastAPI()

if os.path.exists("static"):
    app.mount("/static", StaticFiles(directory="static"), name="static")

templates = Jinja2Templates(directory="templates")
templates.env.globals["enumerate"] = enumerate

# –°—Ç—Ä–∞–Ω–∏—Ü–∞ –≤—Ö–æ–¥–∞ (–µ—Å–ª–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –∞–≤—Ç–æ—Ä–∏–∑–æ–≤–∞–Ω)
@app.get("/login", response_class=HTMLResponse)
async def login_page(request: Request):
    return templates.TemplateResponse("login.html", {"request": request})

# –û–±—Ä–∞–±–æ—Ç–∫–∞ —Ñ–æ—Ä–º—ã –≤—Ö–æ–¥–∞: –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –≤–≤–æ–¥–∏—Ç —Å–≤–æ–π Telegram ID,
# –±–æ—Ç –æ—Ç–ø—Ä–∞–≤–ª—è–µ—Ç –∫–æ–¥ –∏ –∑–∞—Ç–µ–º –ø–µ—Ä–µ–Ω–∞–ø—Ä–∞–≤–ª—è–µ—Ç –Ω–∞ —Å—Ç—Ä–∞–Ω–∏—Ü—É –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏—è.
@app.post("/login", response_class=HTMLResponse)
async def login_post(request: Request, user_id: str = Form(...)):
    data = load_data()
    user = ensure_user(data, user_id)
    # –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º –∫–æ–¥ –∏ –≤—Ä–µ–º—è –∏—Å—Ç–µ—á–µ–Ω–∏—è (5 –º–∏–Ω—É—Ç)
    code = generate_login_code()
    expiry = (datetime.datetime.now() + datetime.timedelta(minutes=5)).timestamp()
    user["login_code"] = code
    user["code_expiry"] = expiry
    save_data(data)
    # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –∫–æ–¥ —á–µ—Ä–µ–∑ –±–æ—Ç–∞
    try:
        await bot.send_message(int(user_id), f"–í–∞—à –∫–æ–¥ –¥–ª—è –≤—Ö–æ–¥–∞: {code}")
    except Exception as e:
        return HTMLResponse("–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ—Ç–ø—Ä–∞–≤–∫–µ –∫–æ–¥–∞ —á–µ—Ä–µ–∑ Telegram.", status_code=500)
    return templates.TemplateResponse("verify.html", {"request": request, "user_id": user_id})

# –û–±—Ä–∞–±–æ—Ç–∫–∞ –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏—è –∫–æ–¥–∞
@app.post("/verify", response_class=HTMLResponse)
async def verify_post(request: Request, user_id: str = Form(...), code: str = Form(...)):
    data = load_data()
    user = data.get("users", {}).get(user_id)
    if not user:
        return HTMLResponse("–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω.", status_code=404)
    # –ü—Ä–æ–≤–µ—Ä—è–µ–º —Å—Ä–æ–∫ –¥–µ–π—Å—Ç–≤–∏—è –∫–æ–¥–∞
    if user.get("code_expiry", 0) < datetime.datetime.now().timestamp():
        return HTMLResponse("–ö–æ–¥ —É—Å—Ç–∞—Ä–µ–ª. –ü–æ–≤—Ç–æ—Ä–∏—Ç–µ –ø–æ–ø—ã—Ç–∫—É –≤—Ö–æ–¥–∞.", status_code=400)
    # –ü—Ä–æ–≤–µ—Ä—è–µ–º –ø—Ä–∞–≤–∏–ª—å–Ω–æ—Å—Ç—å –∫–æ–¥–∞
    if user.get("login_code") != code:
        return HTMLResponse("–ù–µ–≤–µ—Ä–Ω—ã–π –∫–æ–¥.", status_code=400)
    # –ï—Å–ª–∏ –≤—Å—ë –≤–µ—Ä–Ω–æ ‚Äì –æ—á–∏—â–∞–µ–º –∫–æ–¥ –∏ —É—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º cookie
    user["login_code"] = None
    user["code_expiry"] = None
    save_data(data)
    response = RedirectResponse(url=f"/profile/{user_id}", status_code=303)
    response.set_cookie("user_id", user_id, max_age=60*60*24*30, path="/")
    return response

@app.get("/", response_class=HTMLResponse)
async def index(request: Request):
    user_id = request.cookies.get("user_id")
    user = None
    if user_id:
        data = load_data()
        user = data.get("users", {}).get(user_id)
    return templates.TemplateResponse("index.html", {"request": request, "user": user, "user_id": user_id})

@app.get("/market", response_class=HTMLResponse)
async def web_market(request: Request):
    data = load_data()
    market = data.get("market", [])
    buyer_id = request.cookies.get("user_id", "")
    return templates.TemplateResponse("market.html", {"request": request, "market": market, "users": data.get("users", {}), "buyer_id": buyer_id})

@app.get("/profile/{user_id}", response_class=HTMLResponse)
async def profile(request: Request, user_id: str):
    data = load_data()
    user = data.get("users", {}).get(user_id)
    if not user:
        return HTMLResponse("–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω.", status_code=404)
    return templates.TemplateResponse("profile.html", {"request": request, "user": user, "user_id": user_id})

@app.get("/mint", response_class=HTMLResponse)
async def web_mint(request: Request):
    return templates.TemplateResponse("mint.html", {"request": request})

@app.post("/mint", response_class=HTMLResponse)
async def web_mint_post(request: Request, user_id: str = Form(...)):
    data = load_data()
    user = ensure_user(data, user_id)
    today = datetime.date.today().isoformat()
    if user["last_activation_date"] != today:
        user["last_activation_date"] = today
        user["activation_count"] = 0
    if user["activation_count"] >= 3:
        return templates.TemplateResponse("mint.html", {"request": request, "error": "–í—ã –∏—Å—á–µ—Ä–ø–∞–ª–∏ –±–µ—Å–ø–ª–∞—Ç–Ω—ã–µ –∞–∫—Ç–∏–≤–∞—Ü–∏–∏ –Ω–∞ —Å–µ–≥–æ–¥–Ω—è. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –∑–∞–≤—Ç—Ä–∞!", "user_id": user_id})
    user["activation_count"] += 1
    num, score = generate_number()
    entry = {"token": num, "score": score, "timestamp": datetime.datetime.now().isoformat()}
    user["tokens"].append(entry)
    save_data(data)
    return templates.TemplateResponse("profile.html", {"request": request, "user": user, "user_id": user_id})

@app.get("/sell", response_class=HTMLResponse)
async def web_sell(request: Request):
    return templates.TemplateResponse("sell.html", {"request": request})

@app.post("/sell", response_class=HTMLResponse)
async def web_sell_post(request: Request, user_id: str = Form(...), token_index: int = Form(...), price: int = Form(...)):
    data = load_data()
    user = data.get("users", {}).get(user_id)
    if not user:
        return HTMLResponse("–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω.", status_code=404)
    tokens = user.get("tokens", [])
    if token_index < 1 or token_index > len(tokens):
        return HTMLResponse("–ù–µ–≤–µ—Ä–Ω—ã–π –Ω–æ–º–µ—Ä –∏–∑ –≤–∞—à–µ–π –∫–æ–ª–ª–µ–∫—Ü–∏–∏.", status_code=400)
    token = tokens.pop(token_index - 1)
    if "market" not in data:
        data["market"] = []
    listing = {
        "seller_id": user_id,
        "token": token,
        "price": price,
        "timestamp": datetime.datetime.now().isoformat()
    }
    data["market"].append(listing)
    save_data(data)
    return templates.TemplateResponse("profile.html", {"request": request, "user": user, "user_id": user_id})

@app.get("/exchange", response_class=HTMLResponse)
async def web_exchange(request: Request):
    return templates.TemplateResponse("exchange.html", {"request": request})

@app.post("/exchange", response_class=HTMLResponse)
async def web_exchange_post(request: Request, user_id: str = Form(...), my_index: int = Form(...), target_id: str = Form(...), target_index: int = Form(...)):
    data = load_data()
    initiator = data.get("users", {}).get(user_id)
    target = data.get("users", {}).get(target_id)
    if not initiator or not target:
        return HTMLResponse("–û–¥–∏–Ω –∏–∑ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π –Ω–µ –Ω–∞–π–¥–µ–Ω.", status_code=404)
    my_tokens = initiator.get("tokens", [])
    target_tokens = target.get("tokens", [])
    if my_index < 1 or my_index > len(my_tokens) or target_index < 1 or target_index > len(target_tokens):
        return HTMLResponse("–ù–µ–≤–µ—Ä–Ω—ã–π –Ω–æ–º–µ—Ä —É –æ–¥–Ω–æ–≥–æ –∏–∑ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π.", status_code=400)
    my_token = my_tokens.pop(my_index - 1)
    target_token = target_tokens.pop(target_index - 1)
    my_tokens.append(target_token)
    target_tokens.append(my_token)
    save_data(data)
    return templates.TemplateResponse("profile.html", {"request": request, "user": initiator, "user_id": user_id})

@app.get("/participants", response_class=HTMLResponse)
async def web_participants(request: Request):
    data = load_data()
    users = data.get("users", {})
    return templates.TemplateResponse("participants.html", {"request": request, "users": users})

@app.post("/buy/{listing_index}")
async def web_buy(request: Request, listing_index: int, buyer_id: str = Form(...)):
    data = load_data()
    market = data.get("market", [])
    if listing_index < 0 or listing_index >= len(market):
        return HTMLResponse("–ù–µ–≤–µ—Ä–Ω—ã–π –Ω–æ–º–µ—Ä –ª–∏—Å—Ç–∏–Ω–≥–∞.", status_code=400)
    listing = market[listing_index]
    seller_id = listing.get("seller_id")
    price = listing["price"]
    buyer = data.get("users", {}).get(buyer_id)
    if not buyer:
        return HTMLResponse("–ü–æ–∫—É–ø–∞—Ç–µ–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω.", status_code=404)
    if buyer.get("balance", 0) < price:
        return HTMLResponse("–ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ —Å—Ä–µ–¥—Å—Ç–≤.", status_code=400)
    buyer["balance"] -= price
    seller = data.get("users", {}).get(seller_id)
    if seller:
        seller["balance"] = seller.get("balance", 0) + price
    buyer.setdefault("tokens", []).append(listing["token"])
    market.pop(listing_index)
    save_data(data)
    return templates.TemplateResponse("profile.html", {"request": request, "user": buyer, "user_id": buyer_id})

# --------------------- –ó–∞–ø—É—Å–∫ –±–æ—Ç–∞ –∏ –≤–µ–±-—Å–µ—Ä–≤–µ—Ä–∞ ---------------------
async def main():
    bot_task = asyncio.create_task(dp.start_polling(bot))
    config = uvicorn.Config(app, host="0.0.0.0", port=8000, log_level="info")
    server = uvicorn.Server(config)
    web_task = asyncio.create_task(server.serve())
    await asyncio.gather(bot_task, web_task)

if __name__ == "__main__":
    asyncio.run(main())
