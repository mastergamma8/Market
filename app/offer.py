import os
import json
import random
import hashlib
import datetime
import asyncio

from aiogram import Bot, Dispatcher, F
from aiogram.types import Message, InlineKeyboardMarkup, InlineKeyboardButton, CallbackQuery
from aiogram.filters import Command
from fastapi import APIRouter, Request, Form, Body
from fastapi.responses import HTMLResponse, RedirectResponse

# –ò–º–ø–æ—Ä—Ç –æ–±—â–∏—Ö —Ñ—É–Ω–∫—Ü–∏–π –∏ –æ–±—ä–µ–∫—Ç–æ–≤ –∏–∑ –≤–∞—à–µ–≥–æ –ø—Ä–æ–µ–∫—Ç–∞ (common.py)
from common import load_data, save_data, ensure_user, templates, bot, dp

# --- –ë–û–¢: –∫–æ–º–∞–Ω–¥—ã –¥–ª—è –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏—è —Ü–µ–Ω—ã ---

@dp.message(Command("offer"))
async def offer_price_command(message: Message) -> None:
    parts = message.text.split()
    if len(parts) != 3:
        await message.answer("‚ùó –§–æ—Ä–º–∞—Ç: /offer <–Ω–æ–º–µ—Ä —Ç–æ–∫–µ–Ω–∞> <–ø—Ä–µ–¥–ª–æ–∂–µ–Ω–Ω–∞—è —Ü–µ–Ω–∞>")
        return
    token_value = parts[1]
    try:
        proposed_price = int(parts[2])
    except ValueError:
        await message.answer("‚ùó –¶–µ–Ω–∞ –¥–æ–ª–∂–Ω–∞ –±—ã—Ç—å —á–∏—Å–ª–æ–º.")
        return

    data = load_data()
    # –ü–æ–∏—Å–∫ —Ç–æ–∫–µ–Ω–∞: —Å–Ω–∞—á–∞–ª–∞ –≤ –∫–æ–ª–ª–µ–∫—Ü–∏—è—Ö –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π, –∑–∞—Ç–µ–º –≤ –º–∞—Ä–∫–µ—Ç–ø–ª–µ–π—Å–µ
    found = None
    # –ü–æ–∏—Å–∫ –≤ –∫–æ–ª–ª–µ–∫—Ü–∏—è—Ö –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π
    for uid, user in data.get("users", {}).items():
        for token in user.get("tokens", []):
            if token.get("token") == token_value:
                found = (uid, token)
                break
        if found:
            break
    # –ï—Å–ª–∏ –Ω–µ –Ω–∞–π–¥–µ–Ω, –∏—â–µ–º –µ–≥–æ —Å—Ä–µ–¥–∏ –ª–∏—Å—Ç–∏–Ω–≥–æ–≤ –≤ –º–∞—Ä–∫–µ—Ç–ø–ª–µ–π—Å–µ
    if not found:
        for listing in data.get("market", []):
            token = listing.get("token")
            if token and token.get("token") == token_value:
                found = (listing.get("seller_id"), token)
                break

    if not found:
        await message.answer("‚ùó –¢–æ–∫–µ–Ω –Ω–µ –Ω–∞–π–¥–µ–Ω.")
        return

    seller_id, token = found
    buyer_id = str(message.from_user.id)
    if buyer_id == seller_id:
        await message.answer("‚ùó –í—ã –Ω–µ –º–æ–∂–µ—Ç–µ –ø—Ä–µ–¥–ª–æ–∂–∏—Ç—å —Ü–µ–Ω—É —Å–≤–æ–µ–º—É —Å–æ–±—Å—Ç–≤–µ–Ω–Ω–æ–º—É –Ω–æ–º–µ—Ä—É.")
        return

    # –ü—Ä–æ–≤–µ—Ä—è–µ–º –±–∞–ª–∞–Ω—Å –ø–æ–∫—É–ø–∞—Ç–µ–ª—è
    buyer = data.get("users", {}).get(buyer_id)
    if not buyer or buyer.get("balance", 0) < proposed_price:
        await message.answer("‚ùó –ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ —Å—Ä–µ–¥—Å—Ç–≤ –¥–ª—è –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏—è —Ü–µ–Ω—ã.")
        return

    # –°–ø–∏—Å—ã–≤–∞–µ–º —Å—Ä–µ–¥—Å—Ç–≤–∞ (–∑–∞–º–æ—Ä–∞–∂–∏–≤–∞–µ–º –∏—Ö)
    buyer["balance"] -= proposed_price

    offer_id = hashlib.md5(f"{buyer_id}{seller_id}{token_value}{datetime.datetime.now()}".encode()).hexdigest()[:8]
    offer = {
        "offer_id": offer_id,
        "buyer_id": buyer_id,
        "seller_id": seller_id,
        "token": token,
        "proposed_price": proposed_price,
        "timestamp": datetime.datetime.now().isoformat(),
        "status": "pending"
    }
    if "offers" not in data:
        data["offers"] = []
    data["offers"].append(offer)
    save_data(data)

    await message.answer(f"–ü—Ä–µ–¥–ª–æ–∂–µ–Ω–∏–µ —Ü–µ–Ω—ã –¥–ª—è –Ω–æ–º–µ—Ä–∞ {token_value} –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–æ –ø—Ä–æ–¥–∞–≤—Ü—É. –°—Ä–µ–¥—Å—Ç–≤–∞ –≤—Ä–µ–º–µ–Ω–Ω–æ –∑–∞–º–æ—Ä–æ–∂–µ–Ω—ã.")
    keyboard = InlineKeyboardMarkup(inline_keyboard=[
        [InlineKeyboardButton(text="–ü—Ä–∏–Ω—è—Ç—å", callback_data=f"offer_accept_{offer_id}")],
        [InlineKeyboardButton(text="–û—Ç–∫–ª–æ–Ω–∏—Ç—å", callback_data=f"offer_decline_{offer_id}")]
    ])
    try:
        await bot.send_message(int(seller_id),
                               f"–í–∞–º –ø–æ—Å—Ç—É–ø–∏–ª–æ –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏–µ —Ü–µ–Ω—ã –¥–ª—è –Ω–æ–º–µ—Ä–∞ {token_value}.\n"
                               f"–ü—Ä–µ–¥–ª–æ–∂–µ–Ω–Ω–∞—è —Ü–µ–Ω–∞: {proposed_price} üíé",
                               reply_markup=keyboard)
    except Exception as e:
        await message.answer("–û—à–∏–±–∫–∞ –æ—Ç–ø—Ä–∞–≤–∫–∏ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è –ø—Ä–æ–¥–∞–≤—Ü—É.")
        print("–û—à–∏–±–∫–∞ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è –ø—Ä–æ–¥–∞–≤—Ü–∞ –ø–æ –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏—é —Ü–µ–Ω—ã:", e)

@dp.callback_query(lambda c: c.data.startswith("offer_accept_"))
async def offer_accept(callback_query: CallbackQuery) -> None:
    offer_id = callback_query.data[len("offer_accept_"):]
    data = load_data()
    offer = None
    for o in data.get("offers", []):
        if o.get("offer_id") == offer_id and o.get("status") == "pending":
            offer = o
            break
    if not offer:
        await callback_query.answer("–ü—Ä–µ–¥–ª–æ–∂–µ–Ω–∏–µ —É–∂–µ –æ–±—Ä–∞–±–æ—Ç–∞–Ω–æ –∏–ª–∏ –Ω–µ –Ω–∞–π–¥–µ–Ω–æ.", show_alert=True)
        return

    # –í—ã–ø–æ–ª–Ω—è–µ–º –ø–µ—Ä–µ–≤–æ–¥ —Å—Ä–µ–¥—Å—Ç–≤ –∏ –ø–µ—Ä–µ–¥–∞—á—É —Ç–æ–∫–µ–Ω–∞
    buyer_id = offer["buyer_id"]
    seller_id = offer["seller_id"]
    proposed_price = offer["proposed_price"]
    token_value = offer["token"]["token"]

    # –ù–∞–π—Ç–∏ –ø—Ä–æ–¥–∞–≤—Ü–∞ –∏ –ø–æ–∫—É–ø–∞—Ç–µ–ª—è
    buyer = data.get("users", {}).get(buyer_id)
    seller = data.get("users", {}).get(seller_id)
    if not seller or not buyer:
        await callback_query.answer("–û—à–∏–±–∫–∞: –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω.", show_alert=True)
        return

    # –î–æ–±–∞–≤–ª—è–µ–º —Å–ø–∏—Å–∞–Ω–Ω—ã–µ —Å—Ä–µ–¥—Å—Ç–≤–∞ –ø—Ä–æ–¥–∞–≤—Ü—É
    seller["balance"] = seller.get("balance", 0) + proposed_price

    # –ü–µ—Ä–µ–¥–∞—ë–º —Ç–æ–∫–µ–Ω: —É–¥–∞–ª—è–µ–º –µ–≥–æ —É –ø—Ä–æ–¥–∞–≤—Ü–∞, –¥–æ–±–∞–≤–ª—è–µ–º –ø–æ–∫—É–ø–∞—Ç–µ–ª—é
    token = offer["token"]
    # –ò—â–µ–º —Ç–æ–∫–µ–Ω —É –ø—Ä–æ–¥–∞–≤—Ü–∞
    token_removed = False
    for idx, t in enumerate(seller.get("tokens", [])):
        if t.get("token") == token_value:
            seller["tokens"].pop(idx)
            token_removed = True
            break
    if not token_removed:
        # –ï—Å–ª–∏ —Ç–æ–∫–µ–Ω –Ω–µ –Ω–∞–π–¥–µ–Ω –≤ –∫–æ–ª–ª–µ–∫—Ü–∏–∏ –ø—Ä–æ–¥–∞–≤—Ü–∞, –≤–æ–∑–º–æ–∂–Ω–æ, –æ–Ω –≤—ã—Å—Ç–∞–≤–ª–µ–Ω –Ω–∞ –º–∞—Ä–∫–µ—Ç
        for idx, listing in enumerate(data.get("market", [])):
            t = listing.get("token")
            if t and t.get("token") == token_value:
                data["market"].pop(idx)
                token_removed = True
                break
    # –î–æ–±–∞–≤–ª—è–µ–º —Ç–æ–∫–µ–Ω –ø–æ–∫—É–ø–∞—Ç–µ–ª—é
    buyer.setdefault("tokens", []).append(token)

    offer["status"] = "accepted"
    save_data(data)

    # –£–¥–∞–ª—è–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ —Å inline –∫–Ω–æ–ø–∫–∞–º–∏ (–µ—Å–ª–∏ –≤–æ–∑–º–æ–∂–Ω–æ)
    try:
        await callback_query.message.delete()
    except Exception as e:
        print("–û—à–∏–±–∫–∞ —É–¥–∞–ª–µ–Ω–∏—è —Å–æ–æ–±—â–µ–Ω–∏—è:", e)

    try:
        await bot.send_message(int(buyer_id),
                               f"–í–∞—à–µ –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏–µ —Ü–µ–Ω—ã –¥–ª—è –Ω–æ–º–µ—Ä–∞ {token_value} –±—ã–ª–æ –ø—Ä–∏–Ω—è—Ç–æ. –¢–æ–∫–µ–Ω —Ç–µ–ø–µ—Ä—å –≤–∞—à!")
    except Exception as e:
        print("–û—à–∏–±–∫–∞ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è –ø–æ–∫—É–ø–∞—Ç–µ–ª—è:", e)
    await callback_query.answer("–ü—Ä–µ–¥–ª–æ–∂–µ–Ω–∏–µ –ø—Ä–∏–Ω—è—Ç–æ.")

@dp.callback_query(lambda c: c.data.startswith("offer_decline_"))
async def offer_decline(callback_query: CallbackQuery) -> None:
    offer_id = callback_query.data[len("offer_decline_"):]
    data = load_data()
    offer = None
    for o in data.get("offers", []):
        if o.get("offer_id") == offer_id and o.get("status") == "pending":
            offer = o
            break
    if not offer:
        await callback_query.answer("–ü—Ä–µ–¥–ª–æ–∂–µ–Ω–∏–µ —É–∂–µ –æ–±—Ä–∞–±–æ—Ç–∞–Ω–æ –∏–ª–∏ –Ω–µ –Ω–∞–π–¥–µ–Ω–æ.", show_alert=True)
        return

    # –í–æ–∑–≤—Ä–∞—â–∞–µ–º —Å—Ä–µ–¥—Å—Ç–≤–∞ –ø–æ–∫—É–ø–∞—Ç–µ–ª—é
    buyer_id = offer["buyer_id"]
    buyer = data.get("users", {}).get(buyer_id)
    if buyer:
        buyer["balance"] = buyer.get("balance", 0) + offer["proposed_price"]

    offer["status"] = "declined"
    save_data(data)

    # –£–¥–∞–ª—è–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ —Å inline –∫–Ω–æ–ø–∫–∞–º–∏
    try:
        await callback_query.message.delete()
    except Exception as e:
        print("–û—à–∏–±–∫–∞ —É–¥–∞–ª–µ–Ω–∏—è —Å–æ–æ–±—â–µ–Ω–∏—è:", e)

    try:
        await bot.send_message(int(buyer_id),
                               f"–í–∞—à–µ –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏–µ —Ü–µ–Ω—ã –¥–ª—è –Ω–æ–º–µ—Ä–∞ {offer['token']['token']} –±—ã–ª–æ –æ—Ç–∫–ª–æ–Ω–µ–Ω–æ. –°—Ä–µ–¥—Å—Ç–≤–∞ –≤–æ–∑–≤—Ä–∞—â–µ–Ω—ã.")
    except Exception as e:
        print("–û—à–∏–±–∫–∞ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è –ø–æ–∫—É–ø–∞—Ç–µ–ª—è:", e)
    await callback_query.answer("–ü—Ä–µ–¥–ª–æ–∂–µ–Ω–∏–µ –æ—Ç–∫–ª–æ–Ω–µ–Ω–æ.")

# --- –í–ï–ë: —ç–Ω–¥–ø–æ–∏–Ω—Ç—ã —Å –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ–º FastAPI ---

router = APIRouter()

@router.post("/offer", response_class=HTMLResponse)
async def web_offer(request: Request, token_value: str = Form(...), proposed_price: int = Form(...)):
    data = load_data()
    found = None
    # –ü–æ–∏—Å–∫ —Ç–æ–∫–µ–Ω–∞ –≤ –∫–æ–ª–ª–µ–∫—Ü–∏—è—Ö –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π
    for uid, user in data.get("users", {}).items():
        for token in user.get("tokens", []):
            if token.get("token") == token_value:
                found = (uid, token)
                break
        if found:
            break
    # –ï—Å–ª–∏ –Ω–µ –Ω–∞–π–¥–µ–Ω, –∏—â–µ–º –µ–≥–æ —Å—Ä–µ–¥–∏ –ª–∏—Å—Ç–∏–Ω–≥–æ–≤ –Ω–∞ –º–∞—Ä–∫–µ—Ç–ø–ª–µ–π—Å–µ
    if not found:
        for listing in data.get("market", []):
            token = listing.get("token")
            if token and token.get("token") == token_value:
                found = (listing.get("seller_id"), token)
                break

    if not found:
        return HTMLResponse("–¢–æ–∫–µ–Ω –Ω–µ –Ω–∞–π–¥–µ–Ω.", status_code=404)

    seller_id, token = found
    buyer_id = request.cookies.get("user_id")
    if not buyer_id:
        return HTMLResponse("–û—à–∏–±–∫–∞: –Ω–µ –∞–≤—Ç–æ—Ä–∏–∑–æ–≤–∞–Ω.", status_code=403)
    if buyer_id == seller_id:
        return HTMLResponse("–í—ã –Ω–µ –º–æ–∂–µ—Ç–µ –ø—Ä–µ–¥–ª–æ–∂–∏—Ç—å —Ü–µ–Ω—É —Å–≤–æ–µ–º—É —Å–æ–±—Å—Ç–≤–µ–Ω–Ω–æ–º—É –Ω–æ–º–µ—Ä—É.", status_code=400)

    # –ü—Ä–æ–≤–µ—Ä—è–µ–º –∏ —Å–ø–∏—Å—ã–≤–∞–µ–º —Å—Ä–µ–¥—Å—Ç–≤–∞ —É –ø–æ–∫—É–ø–∞—Ç–µ–ª—è
    buyer = data.get("users", {}).get(buyer_id)
    if not buyer or buyer.get("balance", 0) < proposed_price:
        return HTMLResponse("–ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ —Å—Ä–µ–¥—Å—Ç–≤ –¥–ª—è –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏—è —Ü–µ–Ω—ã.", status_code=400)
    buyer["balance"] -= proposed_price

    offer_id = hashlib.md5(f"{buyer_id}{seller_id}{token_value}{datetime.datetime.now()}".encode()).hexdigest()[:8]
    offer = {
        "offer_id": offer_id,
        "buyer_id": buyer_id,
        "seller_id": seller_id,
        "token": token,
        "proposed_price": proposed_price,
        "timestamp": datetime.datetime.now().isoformat(),
        "status": "pending"
    }
    if "offers" not in data:
        data["offers"] = []
    data["offers"].append(offer)
    save_data(data)
    return HTMLResponse(f"–ü—Ä–µ–¥–ª–æ–∂–µ–Ω–∏–µ —Ü–µ–Ω—ã –¥–ª—è –Ω–æ–º–µ—Ä–∞ {token_value} –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–æ –ø—Ä–æ–¥–∞–≤—Ü—É. (Offer ID: {offer_id})")

@router.post("/offer/accept", response_class=HTMLResponse)
async def web_offer_accept(request: Request, offer_id: str = Form(...)):
    data = load_data()
    offer = None
    for o in data.get("offers", []):
        if o.get("offer_id") == offer_id and o.get("status") == "pending":
            offer = o
            break
    if not offer:
        return HTMLResponse("–ü—Ä–µ–¥–ª–æ–∂–µ–Ω–∏–µ —É–∂–µ –æ–±—Ä–∞–±–æ—Ç–∞–Ω–æ –∏–ª–∏ –Ω–µ –Ω–∞–π–¥–µ–Ω–æ.", status_code=404)
    buyer_id = offer["buyer_id"]
    seller_id = offer["seller_id"]
    proposed_price = offer["proposed_price"]
    token_value = offer["token"]["token"]

    # –ù–∞–π—Ç–∏ –ø—Ä–æ–¥–∞–≤—Ü–∞ –∏ –ø–æ–∫—É–ø–∞—Ç–µ–ª—è
    buyer = data.get("users", {}).get(buyer_id)
    seller = data.get("users", {}).get(seller_id)
    if not seller or not buyer:
        return HTMLResponse("–û—à–∏–±–∫–∞: –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω.", status_code=404)
    # –ü–µ—Ä–µ–¥–∞–µ–º —Ç–æ–∫–µ–Ω –æ—Ç –ø—Ä–æ–¥–∞–≤—Ü–∞ –ø–æ–∫—É–ø–∞—Ç–µ–ª—é
    token = offer["token"]
    token_removed = False
    for idx, t in enumerate(seller.get("tokens", [])):
        if t.get("token") == token_value:
            seller["tokens"].pop(idx)
            token_removed = True
            break
    if not token_removed:
        for idx, listing in enumerate(data.get("market", [])):
            t = listing.get("token")
            if t and t.get("token") == token_value:
                data["market"].pop(idx)
                token_removed = True
                break
    buyer.setdefault("tokens", []).append(token)
    # –ü–µ—Ä–µ–≤–æ–¥–∏–º —Å–ø–∏—Å–∞–Ω–Ω—ã–µ —Å—Ä–µ–¥—Å—Ç–≤–∞ –ø—Ä–æ–¥–∞–≤—Ü—É
    seller["balance"] = seller.get("balance", 0) + proposed_price

    offer["status"] = "accepted"
    save_data(data)
    try:
        await bot.send_message(int(buyer_id),
                               f"–í–∞—à–µ –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏–µ —Ü–µ–Ω—ã –¥–ª—è –Ω–æ–º–µ—Ä–∞ {token_value} –±—ã–ª–æ –ø—Ä–∏–Ω—è—Ç–æ. –¢–æ–∫–µ–Ω –ø–µ—Ä–µ–¥–∞–Ω –≤–∞–º!")
    except Exception as e:
        print("–û—à–∏–±–∫–∞ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è –ø–æ–∫—É–ø–∞—Ç–µ–ª—è:", e)
    return HTMLResponse("–ü—Ä–µ–¥–ª–æ–∂–µ–Ω–∏–µ –ø—Ä–∏–Ω—è—Ç–æ.")

@router.post("/offer/decline", response_class=HTMLResponse)
async def web_offer_decline(request: Request, offer_id: str = Form(...)):
    data = load_data()
    offer = None
    for o in data.get("offers", []):
        if o.get("offer_id") == offer_id and o.get("status") == "pending":
            offer = o
            break
    if not offer:
        return HTMLResponse("–ü—Ä–µ–¥–ª–æ–∂–µ–Ω–∏–µ —É–∂–µ –æ–±—Ä–∞–±–æ—Ç–∞–Ω–æ –∏–ª–∏ –Ω–µ –Ω–∞–π–¥–µ–Ω–æ.", status_code=404)
    buyer_id = offer["buyer_id"]
    buyer = data.get("users", {}).get(buyer_id)
    if buyer:
        buyer["balance"] = buyer.get("balance", 0) + offer["proposed_price"]
    offer["status"] = "declined"
    save_data(data)
    try:
        await bot.send_message(int(buyer_id),
                               f"–í–∞—à–µ –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏–µ —Ü–µ–Ω—ã –¥–ª—è –Ω–æ–º–µ—Ä–∞ {offer['token']['token']} –±—ã–ª–æ –æ—Ç–∫–ª–æ–Ω–µ–Ω–æ. –°—Ä–µ–¥—Å—Ç–≤–∞ –≤–æ–∑–≤—Ä–∞—â–µ–Ω—ã.")
    except Exception as e:
        print("–û—à–∏–±–∫–∞ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è –ø–æ–∫—É–ø–∞—Ç–µ–ª—è:", e)
    return HTMLResponse("–ü—Ä–µ–¥–ª–æ–∂–µ–Ω–∏–µ –æ—Ç–∫–ª–æ–Ω–µ–Ω–æ.")
